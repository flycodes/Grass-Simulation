#pragma kernel CullingMain
#pragma kernel PhysicsMain
#pragma kernel SimulationSetup

#define physicsNumThreadsX 16
#define physicsNumThreadsY 16
#define physicsNumThreadsZ 1
#define physicsThreadCount physicsNumThreadsX * physicsNumThreadsY * physicsNumThreadsZ

struct UvData
{
    float2 Position;
};

/*                                                // X 			Y 			Z 			W
RWStructuredBuffer<float4> grassDataABuffer;	// up.x 		up.y 		up.z 		pos.y
RWStructuredBuffer<float4> grassDataBBuffer;	// v1.x 		v1.y 		v1.z 		height
RWStructuredBuffer<float4> grassDataCBuffer;	// v2.x 		v2.y 		v2.z 		dirAlpha
RWStructuredBuffer<float4> pressureDataBuffer;  //
*/
//Shared
//StructuredBuffer<UvData> UvBuffer;	// pos.x 		pos.z
Texture2D<float4> ParameterTexture; // width, bend, height, dirAlpha
SamplerState samplerParameterTexture;

//PerPatch
RWTexture2DArray<float4> SimulationTexture; //v1.xyz, tesslevel; v2.xyz, transition
Texture2D<float4> NormalHeightTexture; //up.xyz, pos.y
SamplerState samplerNormalHeightTexture;

//Per Frame
float deltaTime;
float4x4 viewProjMatrix;
float3 camPos;
float4 gravityVec;
float LodDistanceFullDetail;
float LodDistanceBillboard;
float LodDistanceMax;
float LodDensityFullDetailDistance;
float LodDensityBillboardDistance;
float LodDensityMaxDistance;

//Per Patch
bool applyTransition;
float GrassDataResolution;
int startIndex;
float parameterOffsetX;
float parameterOffsetY;
float4 PatchTexCoord; //x: xStart, y: yStart, z: width, w:height
float4x4 patchModelMatrix;
float4x4 patchModelMatrixInverse;

float4 LocalToWorldPos(float4 pos){
	return mul(patchModelMatrix, pos);
}

float4 LocalToWorldPos(float3 pos){
	return mul(patchModelMatrix, float4(pos, 1.0));
}

float4 WorldToClipPos(float4 pos){
	return mul(viewProjMatrix, pos);
}

float4 WorldToClipPos(float3 pos){
	return WorldToClipPos(float4(pos, 1.0));
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void CullingMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID)
{
	float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    //float2 uvGlobal = lerp(PatchTexCoord.xy, PatchTexCoord.xy + PatchTexCoord.zw, uvLocal);
    float2 uvGlobal = float2(parameterOffsetX, parameterOffsetY) + uvLocal;
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvLocal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);
    float4 simulationData0 = SimulationTexture.Load(uint3(id.xy, 0));
    float4 simulationData1 = SimulationTexture.Load(uint3(id.xy, 1));
    
	float width = parameters.x;
	float bendingFactor = parameters.y;
	float height = parameters.z;
	float invHeight = 1.0 / height;
	float dirAlpha = parameters.w;
	float3 localGroundPos = float3(uvLocal.x, normalHeight.w, uvLocal.y);
	float3 groundPos = LocalToWorldPos(localGroundPos).xyz;
	float3 wV1 = LocalToWorldPos(localGroundPos + simulationData0.xyz).xyz;
	float3 wV2 = LocalToWorldPos(localGroundPos + simulationData1.xyz).xyz;
	//float tessLevel = 0.0;
	//float transition = 1.0;
	
	//direction of the blade
	float3 bladeUp = normalHeight.xyz;
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	float3 bladeDir = normalize(cross(bladeUp, tmp));
	float3 bladeFront = normalize(cross(bladeUp, bladeDir));

	/*bladeUp = normalize(mul(patchModelMatrixInverse, float4(bladeUp, 1))).xyz;
	bladeDir = normalize(mul(patchModelMatrixInverse, float4(bladeDir, 1))).xyz;
	bladeFront = normalize(mul(patchModelMatrixInverse, float4(bladeFront, 1))).xyz;*/

	float3 midPoint = 0.25 * groundPos + 0.5 * wV1 + 0.25 * wV2;

	//Visibility Check
	float3 camDir = groundPos - camPos;
	//Project camdir on the local plane defined by the up-vector
	float3 camDirProj = camDir - dot(camDir, bladeUp) * bladeUp;
	float distance = length(camDir);
	float projDistance = length(camDirProj);
	float3 camDirNorm = normalize(camDir);

	//Height transition
	/*if (applyTransition)
	{
        float t = clamp((distance - LodDistanceFullDetail) / (LodDistanceBillboard - LodDistanceFullDetail), 0.0, 1.0);
        //The relative float of how many instances should be rendered at this position.
        float relativeInstanceCount = lerp(LodDensityFullDetailDistance, LodDensityBillboardDistance, t) ;
        uint instanceID = floor(relativeInstanceCount);
        float instanceT = frac(relativeInstanceCount);
        if (gid.x > instanceID){
            //Unwanted grassblade which should not be visible. Set tessLevel to zero
            SimulationTexture[uint3(id.xy, 0)] = float4(simulationData0.xyz, 0.0);
            return;
        } else if (gid.x == instanceID){
            SimulationTexture[uint3(id.xy, 1)] = float4(simulationData1.xyz, instanceT);
        } else {
            SimulationTexture[uint3(id.xy, 1)] = float4(simulationData1.xyz, 1.0);
        }
    }*/
        		
	/*if (distance > 400.0) //distance >= 200.0
	{
		tessDataBuffer[i].x = 0.0;
        return;
	}*/

	//Orientation Culling
    /*if(abs(dot(camDirNorm, bladeFront)) < 0.1)
    {
        tessDataBuffer[i].x = 0;
        return;
    }*/

    //Depth Culling
    /*float projDistance = length(camDirProj);
    uint value = ceil(max((1.0 - projDistance / 200.0),0.0) * 32.0);

    if(fmod(i,32) >= value)
    {
    	tessDataBuffer[i].x = 0;
        return;
    }*/

    SimulationTexture[uint3(id.xy, 0)] = float4(simulationData0.xyz, 12.0);
}

/*
 * Kernels working on Textures below.
 */
 
float3 CalculateV1(float3 v2, float3 bladeUp, float height, float invHeight){
    float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0 - v2ratio, 0.05 * max(v2ratio, 1.0));
    return bladeUp * height * 0.5 * fac;
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void SimulationSetup(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //uint2 threadGroupCount = uint3(GrassDataResolution / physicsNumThreadsX, GrassDataResolution / physicsNumThreadsY);
    //uint i = (gid.z * threadGroupCount.y + gid.y) * threadGroupCount.x + gid.x * physicsThreadCount + gindex;
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    //float2 uvGlobal = lerp(PatchTexCoord.xy, PatchTexCoord.xy + PatchTexCoord.zw, uvLocal);
    float2 uvGlobal = float2(parameterOffsetX, parameterOffsetY) + uvLocal;
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvLocal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);
    float3 bladeUp = normalHeight.xyz;
    float posY = normalHeight.w;
    float height = parameters.z;
    
    float3 v2 = bladeUp * height;
    float3 v1 = CalculateV1(v2, bladeUp, height, 1.0/height);
    
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
    
    float tessLevel = 12.0;
    float transition = 1.0;
    
    SimulationTexture[uint3(id.xy, 0)] = float4(v1, tessLevel);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, transition);
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void PhysicsMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //uint2 threadGroupCount = uint3(GrassDataResolution / physicsNumThreadsX, GrassDataResolution / physicsNumThreadsY);
    //uint i = (gid.z * threadGroupCount.y + gid.y) * threadGroupCount.x + gid.x * physicsThreadCount + gindex;
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    //float2 uvGlobal = lerp(PatchTexCoord.xy, PatchTexCoord.xy + PatchTexCoord.zw, uvLocal);
    float2 uvGlobal = float2(parameterOffsetX, parameterOffsetY) + uvLocal;
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvLocal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);

    float4 simulationData0 = SimulationTexture.Load(uint3(id.xy, 0));
    float4 simulationData1 = SimulationTexture.Load(uint3(id.xy, 1));
    
	float width = parameters.x;
	float bendingFactor = parameters.y;
	float height = parameters.z;
	float invHeight = 1.0 / height;
	float dirAlpha = parameters.w;
	float3 localGroundPos = float3(uvLocal.x, normalHeight.w, uvLocal.y);
	float3 groundPos = LocalToWorldPos(localGroundPos).xyz;
	
	//direction of the blade
	float3 bladeUp = normalHeight.xyz;
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	float3 bladeDir = normalize(cross(bladeUp, tmp));
	float3 bladeFront = normalize(cross(bladeUp, bladeDir));

	float mdt = min(deltaTime, 1.0);

	//float4 oldPressure = pressureDataBuffer[i];
	//float collisionForce = max(oldPressure.w - (1.0 - bendingFactor) * 0.5 * mdt, 0.0);
    
    //TODO
    
	float3 idleV2 = bladeUp * height;
	//apply old pressure
	//float3 v2 = idleV2 - oldPressure.xyz;
	float3 v2 = simulationData1.xyz;
	//float3 relativeV2 = v2 - groundPos;

	//gravity
	float3 gravity = normalize(gravityVec.xyz) * gravityVec.w;
	float sign = step(-0.01, dot(normalize(gravity), bladeFront)) * 2.0 - 1.0;
	gravity += sign * bladeFront * height * gravityVec.w * 0.25f;
	gravity = gravity * height * bendingFactor * mdt;

	//wind
	//TODO

	//stiffness //TODO: Rework temp max without collisionForce
	float3 stiffness = (idleV2 - v2) * (1.0 - bendingFactor * 0.25) * max(0.0, 0.1) * mdt;

	//apply new forces
	v2 += gravity + stiffness;
	//relativeV2 = v2 - groundPos;   
	
	//Ensure valid v2 position (not under ground plane)
	v2 += bladeUp * -min(dot(bladeUp, v2),0.0);

	//Calculate V1
	float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0 - v2ratio, 0.05 * max(v2ratio, 1.0));
    float3 v1 =  bladeUp * height * 0.5 * fac;

	//Make persistent length
	
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
	
	//TODO: Collisions

    SimulationTexture[uint3(id.xy, 0)] = float4(v1, simulationData0.w);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, simulationData1.w);
	//float3 pressure = v2 - idleV2;
	//grassDataBBuffer[i].xyz = v1;
	//grassDataCBuffer[i].xyz = v2;
	//pressureDataBuffer[i].xyz = pressure;
	//pressureDataBuffer[i].w = collisionForce;

}
