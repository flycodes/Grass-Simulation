#pragma kernel CullingMain
#pragma kernel PhysicsMain

#define threads_x 64
#define threads_y 1
#define threads_z 1

StructuredBuffer<float4> SharedGrassDataBuffer; //pos.xz, width, bend
RWStructuredBuffer<float4> grassDataABuffer; //xyz: upVector, w: pos.y
RWStructuredBuffer<float4> grassDataBBuffer; //xyz: v1, w: height
RWStructuredBuffer<float4> grassDataCBuffer; //xyz: v2, w: dirAlpha
RWStructuredBuffer<float4> pressureDataBuffer; //
RWStructuredBuffer<float4> tessDataBuffer; //x: tessLevel

float deltaTime;
int startIndex;
float4 gravityVec;
float4x4 patchModelMatrix;
float4x4 patchModelMatrixInverse;
float4x4 viewProjMatrix;
float3 camPos;

float4 LocalToWorldPos(float4 pos){
	return mul(patchModelMatrix, pos);
}

float4 LocalToWorldPos(float3 pos){
	return mul(patchModelMatrix, float4(pos, 1.0));
}

float4 WorldToClipPos(float4 pos){
	return mul(viewProjMatrix, pos);
}

float4 WorldToClipPos(float3 pos){
	return WorldToClipPos(float4(pos, 1.0));
}

[numthreads(threads_x,threads_y,threads_z)]
void CullingMain (uint3 id : SV_DispatchThreadID, uint gi : SV_GroupIndex)
{
	uint i = id.x;
	/*if (i > 0) {
		tessDataBuffer[i].x = 0;
		return;
	}*/
	//grassDataBBuffer[i].w = 0.3;
	//grassDataCBuffer[i].w = 0.1;

	float dirAlpha = grassDataCBuffer[i].w;
	float3 localPos = float3(SharedGrassDataBuffer[startIndex + i].x, grassDataABuffer[i].w, SharedGrassDataBuffer[startIndex + i].y);
	float3 pos = LocalToWorldPos(localPos).xyz;
	float3 wV1 = LocalToWorldPos(localPos + float3(grassDataBBuffer[i].xyz)).xyz;
	float3 wV2 = LocalToWorldPos(localPos + float3(grassDataCBuffer[i].xyz)).xyz;
	
	//direction of the blade
	float3 bladeUp = normalize(grassDataABuffer[i].xyz);
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	float3 bladeDir = normalize(cross(bladeUp, tmp));
	float3 bladeFront = normalize(cross(bladeUp, bladeDir));

	/*bladeUp = normalize(mul(patchModelMatrixInverse, float4(bladeUp, 1))).xyz;
	bladeDir = normalize(mul(patchModelMatrixInverse, float4(bladeDir, 1))).xyz;
	bladeFront = normalize(mul(patchModelMatrixInverse, float4(bladeFront, 1))).xyz;*/

	float3 midPoint = 0.25 * pos + 0.5 * wV1 + 0.25 * wV2;

	//Visibility Check
	float3 camDir = pos - camPos;
	float3 camDirProj = camDir - dot(camDir, bladeUp) * bladeUp;
	float distance = length(camDir);
	float3 camDirNorm = normalize(camDir);
	
	if (distance > 400.0) //distance >= 200.0
	{
		tessDataBuffer[i].x = 0.0;
        return;
	}

	//Orientation Culling
    /*if(abs(dot(camDirNorm, bladeFront)) < 0.1)
    {
        tessDataBuffer[i].x = 0;
        return;
    }*/

    //Depth Culling
    float projDistance = length(camDirProj);
    uint value = ceil(max((1.0 - projDistance / 200.0),0.0) * 32.0);

    if(fmod(i,32) >= value)
    {
    	tessDataBuffer[i].x = 0;
        return;
    }

    tessDataBuffer[i].x = min(abs(64 - distance), 64);
}

[numthreads(threads_x,threads_y,threads_z)]
void PhysicsMain (uint3 id : SV_DispatchThreadID)
{
	uint i = id.x;

	float dirAlpha = grassDataCBuffer[i].w;
	float height = grassDataBBuffer[i].w;
	float invHeight = 1.0f / height;
	float width = SharedGrassDataBuffer[startIndex + i ].z;
	float bendingFactor = SharedGrassDataBuffer[startIndex + i ].w;
	float3 localGroundPos = float3(SharedGrassDataBuffer[startIndex + i].x, grassDataABuffer[i].w, SharedGrassDataBuffer[startIndex + i].y);
	float3 groundPos = LocalToWorldPos(localGroundPos).xyz;
	
	//direction of the blade
	float3 bladeUp = (grassDataABuffer[i].xyz);
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	float3 bladeDir = normalize(cross(bladeUp, tmp));
	float3 bladeFront = normalize(cross(bladeUp, bladeDir));

	float mdt = min(deltaTime, 1.0f);

	float4 oldPressure = pressureDataBuffer[i];
	float collisionForce = max(oldPressure.w - (1.0f - bendingFactor) * 0.5f * mdt, 0.0f);

	float3 idleV2 = bladeUp * height;

	//apply old pressure
	//float3 v2 = idleV2 - oldPressure.xyz;
	float3 v2 = grassDataCBuffer[i].xyz;
	//float3 relativeV2 = v2 - groundPos;

	//gravity
	float3 gravity = normalize(gravityVec.xyz) * gravityVec.w;
	float sign = step(-0.01f, dot(normalize(gravity), bladeFront)) * 2.0f - 1.0f;
	gravity += sign * bladeFront * height * gravityVec.w * 0.25f;
	gravity = gravity * height * bendingFactor * mdt;

	//wind
	//TODO

	//stiffness
	float3 stiffness = (idleV2 - v2) * (1.0f - bendingFactor * 0.25f) * max(1.0f - collisionForce, 0.1f) * mdt;

	//apply new forces
	v2 += gravity + stiffness;
	//relativeV2 = v2 - groundPos;

	//Ensure valid v2 position (not under ground plane)
	v2 += bladeUp * -min(dot(bladeUp, v2),0.0f);

	//Calculate V1
	float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0f - v2ratio, 0.05f * max(v2ratio, 1.0f));
    float3 v1 =  bladeUp * height * 0.5f;

	//Make persistent length
	
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);
    float L = (2.0f * L0 + L1) / 3.0f; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
	
	//TODO: Collisions

	float3 pressure = v2 - idleV2;
	grassDataBBuffer[i].xyz = v1;
	grassDataCBuffer[i].xyz = v2;
	pressureDataBuffer[i].xyz = pressure;
	pressureDataBuffer[i].w = collisionForce;

}
