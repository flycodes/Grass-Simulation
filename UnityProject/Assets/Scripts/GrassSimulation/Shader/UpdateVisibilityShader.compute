#pragma kernel CSMain

#define threads_x 64
#define threads_y 1
#define threads_z 1

int startIndex;
float4x4 patchModelMatrix;
float3x3 patchModelMatrixInverse;
float4x4 viewProjMatrix;
float3 camPos;

StructuredBuffer<float4> SharedGrassData; //pos.xz, width, bend
RWStructuredBuffer<float4> grassDataA; //xyz: upVector, w: pos.y
RWStructuredBuffer<float4> grassDataB; //xyz: v1, w: height
RWStructuredBuffer<float4> grassDataC; //xyz: v2, w: dirAlpha
RWStructuredBuffer<float4> tessData; //x: tessLevel

float4 LocalToWorldPos(float4 pos){
	return mul(patchModelMatrix, pos);
}

float4 LocalToWorldPos(float3 pos){
	return mul(patchModelMatrix, float4(pos, 1.0));
}

float4 WorldToClipPos(float4 pos){
	return mul(viewProjMatrix, pos);
}

float4 WorldToClipPos(float3 pos){
	return WorldToClipPos(float4(pos, 1.0));
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint gi : SV_GroupIndex)
{
	//grassDataB[gi].w = 0.1 * gi;
	//grassDataC[gi].w = 10.0;

	float dirAlpha = grassDataC[gi].w;
	float3 localPos = float3(SharedGrassData[startIndex + gi].x, grassDataA[gi].w, SharedGrassData[startIndex + gi].z);
	float3 pos = LocalToWorldPos(localPos).xyz;
	float3 wV1 = LocalToWorldPos(localPos + float3(grassDataB[gi].xyz)).xyz;
	float3 wV2 = LocalToWorldPos(localPos + float3(grassDataC[gi].xyz)).xyz;
	
	//direction of the blade
	float3 bladeUp = grassDataA[gi].xyz;
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	float3 bladeDir = normalize(cross(bladeUp, tmp));
	float3 bladeFront = normalize(cross(bladeUp, bladeDir));

	bladeUp = normalize(mul(patchModelMatrixInverse, bladeUp));
	bladeDir = normalize(mul(patchModelMatrixInverse, bladeDir));
	bladeFront = normalize(mul(patchModelMatrixInverse, bladeFront));

	float3 midPoint = 0.25 * pos + 0.5 * wV1 + 0.25 * wV2;

	//Visibility Check
	float3 camDir = pos - wV1;
	float3 camDirProj = camDir - dot(camDir, bladeUp) * bladeUp;
	float distance = length(camDir);
	float3 camDirNorm = camDir / distance;

	/*if (distance >= 200.0)
	{
		tessData[gi].x = 0;
        return;
	}*/

	//Orientation
    /*if(abs(dot(camDirNorm, bladeDir)) >= 0.9)
    {
        tessData[gi].x = 0;
        return;
    }*/

    tessData[gi].x = 4.0;
}
