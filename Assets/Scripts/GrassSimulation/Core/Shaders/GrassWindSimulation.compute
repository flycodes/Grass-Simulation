#pragma kernel SetupField
#pragma kernel UpdateField

#define fluidNumThreadsX 16
#define fluidNumThreadsY 16
#define fluidNumThreadsZ 1
#define fluidThreadCount fluidNumThreadsX * fluidNumThreadsY * fluidNumThreadsZ

float Viscosity;
float PressureScale;
//float DensityViscosity;
float DeltaTime;

float input;

//float WindDensityResolution;
float WindFieldResolution;
//float DensityStep;
float FieldStep;

static const float CentralScale = 1.0/2.0;
#define DX 1.0
#define DIFF (1.0 / (2.0 * DX))
#define DDIFF (1.0 / (DX * DX))
static const float2 Directions[4] = 
{
	float2(1, 0),
	float2(0, 1),
	float2(-1, 0),
	float2(0, -1)
};

Texture2D<float4> CollisionDepthTexture; //up.xyz, pos.y
SamplerState samplerCollisionDepthTexture;

RWTexture2D<float4> WindFieldRenderTexture;
Texture2D<float4> WindFieldTexture;
SamplerState samplerWindFieldTexture;

/*RWTexture2D<float4> WindDensityRenderTexture;
Texture2D<float4> WindDensityTexture;
SamplerState samplerWindDensityTexture;*/

SamplerState samplerPointClamp;
SamplerState samplerLinearClamp;

bool IsBoundary(float2 UV)
{
	return (UV.x<=FieldStep || UV.x>(1.0f-FieldStep) || UV.y<=FieldStep || UV.y>(1.0f-FieldStep));
}

[numthreads(fluidNumThreadsX,fluidNumThreadsY,fluidNumThreadsZ)]
void SetupField (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(id.x/WindFieldResolution, id.y/WindFieldResolution);
    float4 u = float4(0, 0, 0, 1);

    WindFieldRenderTexture[id.xy] = u;
}

[numthreads(fluidNumThreadsX,fluidNumThreadsY,fluidNumThreadsZ)]
void UpdateField (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(id.x/WindFieldResolution + 0.5/WindFieldResolution, id.y/WindFieldResolution + 0.5/WindFieldResolution);
    float2 uvCollisionTexture = uv;
    uvCollisionTexture.x = 1 - uvCollisionTexture.x;
    
    float4 u = WindFieldTexture.SampleLevel(samplerPointClamp, uv, 0);
    
    float3 uLeft = WindFieldTexture.SampleLevel(samplerPointClamp, uv - float2(FieldStep, 0), 0).xyw;
    float3 uRight = WindFieldTexture.SampleLevel(samplerPointClamp, uv + float2(FieldStep, 0), 0).xyw;
    float3 uBottom = WindFieldTexture.SampleLevel(samplerPointClamp, uv - float2(0, FieldStep), 0).xyw;
    float3 uTop = WindFieldTexture.SampleLevel(samplerPointClamp, uv + float2(0, FieldStep), 0).xyw;

    float2 laplacian = DDIFF * ((uLeft.xy + uRight.xy + uBottom.xy + uTop.xy) - 4.0 * u.xy);
    
    float3 UdX = DIFF * (uRight - uLeft);
    float3 UdY = DIFF * (uTop - uBottom);

    // Mass Conservation (Density)
    float2 rGrad = float2(UdX.z, UdY.z);
    float3 Temp = float3(rGrad, UdX.x + UdY.y);
    u.w = clamp(u.w - DeltaTime * dot(u.xyw, Temp), 0.3, 1.7);
    
    // Momentum Conservation (Velocity)
	float2 Was = uv - DeltaTime * u.xy * float2(FieldStep, FieldStep);
	u.xy = WindFieldTexture.SampleLevel(samplerLinearClamp, Was, 0).xy;	
	
	float2 PdX = (PressureScale / DeltaTime) * rGrad;
    float2 viscosityForce = Viscosity * laplacian;
    
    ///< Semi-Langrangian.
	
	float4 cDataAtV2 = CollisionDepthTexture.SampleLevel(samplerCollisionDepthTexture, uvCollisionTexture, 0);
	
	if (cDataAtV2.a > 0.3 && cDataAtV2.a < 0.5){ 
        u.xy *= 0;
        return;
	}
	float2 externalForces = float2(0, 0);
    //if (WindDensityTexture.SampleLevel(samplerPointClamp, uv, 0).x > 0.1)
    /*if (1 - cDataAtV2.a > 0.5)
    {
        externalForces = float2(0, 1 - cDataAtV2.a);
    }*/
    /*if (id.x == 30) externalForces.x = -0.5 * input;
    if (id.y == 30) externalForces.y = 0.5 * input;
    if (id.x == 50 && id.y == 50) externalForces.x = 1.0 * input;*/
    /*if (input == 1){
        externalForces.x = sin(uv.x * 3.14) * cDataAtV2.a;
        externalForces.y = cos(uv.y * 3.14) * cDataAtV2.a;
    }*/
    
    //externalForces.xy = float2(0.1, 0.1);
    externalForces.xy += 0.1 * (cDataAtV2.xy);
        
	u.xy += DeltaTime * (- PdX + viscosityForce + externalForces);
	
	for (int i = 0; i < 4; ++i)
	{
		if (IsBoundary(uv + float2(FieldStep, FieldStep) * Directions[i])) 
		{	
			float2 SetToZero=(1 - abs(Directions[i]));
			u.xy *= SetToZero;
		}
	}
    
    WindFieldRenderTexture[id.xy] = u;
}
/*
[numthreads(fluidNumThreadsX,fluidNumThreadsY,fluidNumThreadsZ)]
void SetupDensity (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(id.x/WindDensityResolution, id.y/WindDensityResolution);
    WindDensityRenderTexture[id.xy] = float4(uv.xxx * 5, 1);
}

[numthreads(fluidNumThreadsX,fluidNumThreadsY,fluidNumThreadsZ)]
void UpdateDensity (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(id.x/WindDensityResolution, id.y/WindDensityResolution);
    
    float2 Density = WindDensityTexture.SampleLevel(samplerPointClamp, uv, 0).xy;
    
    float4 Neighbours = float4(
        WindDensityTexture.SampleLevel(samplerPointClamp, uv + float2(DensityStep, 0), 0).x,
        WindDensityTexture.SampleLevel(samplerPointClamp, uv - float2(DensityStep, 0), 0).x,
        WindDensityTexture.SampleLevel(samplerPointClamp, uv + float2(0, DensityStep), 0).x,
        WindDensityTexture.SampleLevel(samplerPointClamp, uv - float2(0, DensityStep), 0).x
    );
    
    float4 visualDensityGradient = float4(-CentralScale * (Neighbours.xz - Neighbours.yw), DensityViscosity.xx);
    float4 visualDensityLaplacian = float4(WindFieldTexture.SampleLevel(samplerLinearClamp, uv, 0).xy, Neighbours.xz + Neighbours.yw - 2 * Density.xx);
    
    float3 forces = float3(dot(visualDensityGradient, visualDensityLaplacian), Density.y * 0.02, -0.004);
    
    Density.x = clamp(Density.x + DeltaTime * dot(forces, float3(1, 1, 1)), 0.0, 2.0);
    
    WindDensityRenderTexture[id.xy] = float4(Density, 0, 1);
}
*/