#pragma kernel PhysicsMain
#pragma kernel SimulationSetup

#define physicsNumThreadsX 16
#define physicsNumThreadsY 16
#define physicsNumThreadsZ 1
#define physicsThreadCount physicsNumThreadsX * physicsNumThreadsY * physicsNumThreadsZ

#include "GrassFuncs.cginc"

//Once
float4x4 CollisionViewProj;
float3 CollisionVolumeSize;
float3 CollisionVolumeMin;
float3 CollisionVolumeMax;
float LodTessellationMin;
float LodTessellationMax;
float LodDistanceTessellationMin;
float LodDistanceTessellationMax;
float4 NormalHeightUvCorrection;
float RecoveryFactor;

Texture2D GrassMapTexture;
Texture2D<float4> ParameterTexture; // width, bend, height, dirAlpha
SamplerState samplerParameterTexture;
            
//PerPatch
float GrassDataResolution;
float ParameterOffsetX;
float ParameterOffsetY;
float4x4 PatchModelMatrix;
float4 PatchTexCoord; //x: xStart, y: yStart, z: width, w:height
int StartIndex;

Texture2D<float4> CollisionDepthTexture; //up.xyz, pos.y
SamplerState samplerCollisionDepthTexture;
Texture2D<float4> NormalHeightTexture; //up.xyz, pos.y
SamplerState samplerNormalHeightTexture;
RWTexture2DArray<float4> SimulationTexture; //v1.xyz, tesslevel; v2.xyz, transition

//Per Frame
float3 CamPos;
float DeltaTime;
float Time;
float4x4 ViewProjMatrix;
float4 GravityVec;
float4 WindData;

float4 LocalToWorldPos(float4 pos){ return mul(PatchModelMatrix, pos); }
float4 LocalToWorldPos(float3 pos){ return mul(PatchModelMatrix, float4(pos, 1.0)); }
float4 WorldToClipPos(float4 pos){ return mul(ViewProjMatrix, pos); }
float4 WorldToClipPos(float3 pos){ return WorldToClipPos(float4(pos, 1.0)); }
float4 GetCollisionVolumePos(float3 worldpos){ return mul(CollisionViewProj, float4(worldpos, 1.0)); }

float3 GetV1(in float3 v2, in float3 bladeUp, in float height, in float invHeight)
{
    float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0 - v2ratio, 0.05 * max(v2ratio, 1.0));
    return bladeUp * height * 0.5 * fac;
}

void AdjustBezierArcLength(inout float3 v1, inout float3 v2, in float height)
{
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
}

void ValidateV2(inout float3 v2, in float3 bladeUp)
{
    //Ensure valid v2 position (not under ground plane)
	v2 += bladeUp * -min(dot(bladeUp, v2), 0);
}

void CalculateBladeDirAndFront(in float3 bladeUp, in float dirAlpha, out float3 bladeDir, out float3 bladeFront)
{
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	bladeDir = normalize(cross(bladeUp, tmp));
	bladeFront = normalize(cross(bladeUp, bladeDir));
}

/*
 * Kernels below.
 */ 

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void SimulationSetup(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //Create all the needed uv coordinates
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    float2 uvNormalHeight = lerp(NormalHeightUvCorrection.xy, NormalHeightUvCorrection.zw, uvLocal);
    float2 uvParameter = float2(ParameterOffsetX, ParameterOffsetY) + uvLocal;
    
    //Read all the textures -°O°/
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvNormalHeight, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvParameter, 0);
    
    //Create and name all needed variables
    float3 bladeUp = normalize(normalHeight.xyz);
    float height = parameters.z;
    float3 v2 = bladeUp * height;
    float3 v1 = GetV1(v2, bladeUp, height, 1.0 / height);
    
    AdjustBezierArcLength(v1, v2, height);

    float collisionForce = 0;
    float distance = 1.0;
    
    SimulationTexture[uint3(id.xy, 0)] = float4(v1, collisionForce);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, distance);
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void PhysicsMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //Create all the needed uv coordinates
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    float2 uvNormalHeight = lerp(NormalHeightUvCorrection.xy, NormalHeightUvCorrection.zw, uvLocal);
    float2 uvGlobal = lerp(PatchTexCoord.xy, PatchTexCoord.xy + PatchTexCoord.zw, uvLocal);
    float2 uvCollisionTexture = uvGlobal;
    uvCollisionTexture.x = 1 - uvCollisionTexture.x;
    float2 uvParameter = float2(ParameterOffsetX, ParameterOffsetY) + uvLocal;
    
    //Read all the textures -°O°/
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvNormalHeight, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvParameter, 0);
    float4 grassMapData = GrassMapTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);
    float4 simulationData0 = SimulationTexture.Load(uint3(id.xy, 0));
    float4 simulationData1 = SimulationTexture.Load(uint3(id.xy, 1));
    
    //Create and name all needed variables
	float width = parameters.x;
	float bendingFactor = parameters.y;
	float height = parameters.z * grassMapData.z;
	float invHeight = 1.0 / height;
	float dirAlpha = parameters.w;
	float3 localV0 = float3(uvLocal.x, normalHeight.w, uvLocal.y);
	float3 v0 = LocalToWorldPos(localV0).xyz;
	float3 bladeUp = normalize(normalHeight.xyz);
	float3 bladeDir;
	float3 bladeFront;
	CalculateBladeDirAndFront(bladeUp, dirAlpha, bladeDir, bladeFront);
	float mdt = DeltaTime;//min(DeltaTime, 1.0);
	float3 idleV2 = bladeUp * height;
	float3 v2 = simulationData1.xyz;
	float collisionForce = max(simulationData0.w - (1.0 - bendingFactor) * RecoveryFactor * mdt, 0.0);

	//Gravity
	float3 gravity = normalize(GravityVec.xyz) * GravityVec.w;
	float sign = step(-0.01, dot(normalize(gravity), bladeFront)) * 2.0 - 1.0;
	gravity += sign * bladeFront * height * GravityVec.w * 0.25;
	gravity = gravity * height * bendingFactor * mdt;

	//Wind
	float windageHeight = abs(dot(v2, bladeUp)) * invHeight;
	float windageDir = 1.0 - abs(dot(normalize(WindData.xyz), normalize(v2)));
	float windPos = 1.0f - max((cos((v0.x + v0.z) * 0.75f + WindData.w) + sin((v0.x + v0.y) * 0.5f + WindData.w) + sin((v0.y + v0.z) * 0.25f + WindData.w)) / 3.0f, 0.0f);
	float3 wind = WindData.xyz * windageDir * windageHeight * windPos * windPos * bendingFactor * mdt;
	
	//Stiffness 
	float3 stiffness = (idleV2 - v2) * (1.0 - bendingFactor * 0.5) * max(1.0 - collisionForce, 0.0) * mdt;

	//apply new forces
	v2 += gravity + wind + stiffness;

	ValidateV2(v2, bladeUp);
    float3 v1 = GetV1(v2, bladeUp, height, invHeight);
    AdjustBezierArcLength(v1, v2, height);
    
    //Collisions
    bool dataDirty = false;
    float3 cV0 = (GetCollisionVolumePos(v0).xyz + 1)/2;

    //Test collision with v2
    float3 cV2 = (GetCollisionVolumePos(v0 + v2).xyz + 1)/2;
    float4 cDataAtV2 = CollisionDepthTexture.SampleLevel(samplerCollisionDepthTexture, cV2.xy, 0);
    float cDepthAtV2 = 1 - cDataAtV2.a;
    float cPressureAtV2 = min(0, max(-cV0.z, cDepthAtV2 - cV2.z));
    if (cPressureAtV2 < 0)
    {
        dataDirty = true;
        v2.xyz -= cDataAtV2.xyz * cPressureAtV2;
        v2.xyz -= gravity * (cPressureAtV2 * CollisionVolumeSize.y);
        collisionForce += max(length(cDataAtV2.xyz), abs(cPressureAtV2 * CollisionVolumeSize.y));
    }
    
    //Test collision with beziers midPoint
    float3 midPoint = 0.5f * v1 + 0.25f * v2;
    float3 cMidPoint = (GetCollisionVolumePos(v0 + midPoint).xyz + 1)/2;
    float4 cDataAtMidPoint = CollisionDepthTexture.SampleLevel(samplerCollisionDepthTexture, cMidPoint.xy, 0);
    float cDepthAtMidPoint = 1 - cDataAtMidPoint.a;
    float cPressureAtMidPoint = min(0, max(-cV0.z, cDepthAtMidPoint - cMidPoint.z));
    if (cPressureAtMidPoint < 0)
    {
        dataDirty = true;
        v2.xyz -= 4 * cDataAtMidPoint.xyz * cPressureAtMidPoint;
        v2.xyz -= 4 * gravity * (cPressureAtMidPoint * CollisionVolumeSize.y);
        collisionForce += max(length(cDataAtMidPoint.xyz), abs(cPressureAtV2 * CollisionVolumeSize.y));
    }

    if (dataDirty)
    {
        ValidateV2(v2, bladeUp);
        v1 = GetV1(v2, bladeUp, height, invHeight);
        AdjustBezierArcLength(v1, v2, height);
    }
    
    float3 camDir = v0 - CamPos;
	float distance = length(camDir);

    SimulationTexture[uint3(id.xy, 0)] = float4(v1, collisionForce);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, distance);
}