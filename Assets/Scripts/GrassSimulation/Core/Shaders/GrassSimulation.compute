#pragma kernel PhysicsMain
#pragma kernel SimulationSetup

#define physicsNumThreadsX 16
#define physicsNumThreadsY 16
#define physicsNumThreadsZ 1
#define physicsThreadCount physicsNumThreadsX * physicsNumThreadsY * physicsNumThreadsZ

#include "GrassFuncs.cginc"

static const float MIN_COLLISION_DEPTH = 0.001;

//Once
float4x4 CollisionViewProj;
float3 CollisionVolumeSize;
float3 CollisionVolumeMin;
float3 CollisionVolumeMax;
float LodTessellationMin;
float LodTessellationMax;
float LodDistanceTessellationMin;
float LodDistanceTessellationMax;
float4 NormalHeightUvCorrection;
float RecoveryFactor;

Texture2D GrassMapTexture;
Texture2D<float4> ParameterTexture; // width, bend, height, dirAlpha
SamplerState samplerParameterTexture;
            
//PerPatch
float GrassDataResolution;
float ParameterOffsetX;
float ParameterOffsetY;
float4x4 PatchModelMatrix;
float4 PatchTexCoord; //x: xStart, y: yStart, z: width, w:height
int StartIndex;

Texture2D<float4> CollisionDepthTexture; //up.xyz, pos.y
SamplerState samplerCollisionDepthTexture;
Texture2D<float4> NormalHeightTexture; //up.xyz, pos.y
SamplerState samplerNormalHeightTexture;
RWTexture2DArray<float4> SimulationTexture; //v1.xyz, tesslevel; v2.xyz, transition

//Per Frame
float3 CamPos;
float DeltaTime;
float Time;
float4x4 ViewProjMatrix;
float4 GravityVec;
float4 WindData;

float4 LocalToWorldPos(float4 pos){ return mul(PatchModelMatrix, pos); }
float4 LocalToWorldPos(float3 pos){ return mul(PatchModelMatrix, float4(pos, 1.0)); }
float4 WorldToClipPos(float4 pos){ return mul(ViewProjMatrix, pos); }
float4 WorldToClipPos(float3 pos){ return WorldToClipPos(float4(pos, 1.0)); }
float4 GetCollisionVolumePos(float3 worldpos){ return mul(CollisionViewProj, float4(worldpos, 1.0)); }

float3 GetV1(in float3 v2, in float3 bladeUp, in float height, in float invHeight)
{
    float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0 - v2ratio, 0.05 * max(v2ratio, 1.0));
    return bladeUp * height * 0.5 * fac;
}

void AdjustBezierArcLength(inout float3 v1, inout float3 v2, in float height)
{
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
}

void ValidateV2Tex(inout float3 v2, in float3 v0)
{
    float3 cV2 = (GetCollisionVolumePos(v0 + v2).xyz + 1)/2;
    float height = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, cV2.xy, 0).w * PatchModelMatrix[1][1] + PatchModelMatrix[1][3];
	v2.y = max(v0.y + v2.y, height) - v0.y;
}

void ValidateV2(inout float3 v2, in float3 bladeUp)
{
    //Ensure valid v2 position (not under ground plane)
	v2 += bladeUp * -min(dot(bladeUp, v2), 0);
}

void CalculateBladeDirAndFront(inout float3 bladeUp, in float dirAlpha, out float3 bladeDir, out float3 bladeFront)
{
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	bladeDir = normalize(cross(bladeUp, tmp));
	bladeFront = normalize(cross(bladeUp, bladeDir));
	//bladeUp = normalize(bladeUp + 0.3 * bladeFront);
}

/*
 * Kernels below.
 */ 

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void SimulationSetup(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //Create all the needed uv coordinates
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    float2 uvGlobal = lerp(PatchTexCoord.xy, PatchTexCoord.xy + PatchTexCoord.zw, uvLocal);
    //float2 uvNormalHeight = lerp(NormalHeightUvCorrection.xy, NormalHeightUvCorrection.zw, uvLocal);
    float2 uvParameter = float2(ParameterOffsetX, ParameterOffsetY) + uvLocal;
    
    //Read all the textures -°O°/
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvGlobal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvParameter, 0);
    
    //Create and name all needed variables
    float3 bladeUp = normalize(normalHeight.xyz);
    float height = parameters.z;
    float3 v2 = bladeUp * height;
    float3 v1 = GetV1(v2, bladeUp, height, 1.0 / height);
    
    AdjustBezierArcLength(v1, v2, height);

    float collisionForce = 0;
    float distance = 1.0;
    
    SimulationTexture[uint3(id.xy, 0)] = float4(v1, collisionForce);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, distance);
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void PhysicsMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //Create all the needed uv coordinates
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    //float2 uvNormalHeight = lerp(NormalHeightUvCorrection.xy, NormalHeightUvCorrection.zw, uvLocal);
    float2 uvGlobal = lerp(PatchTexCoord.xy, PatchTexCoord.xy + PatchTexCoord.zw, uvLocal);
    float2 uvCollisionTexture = uvGlobal;
    //uvCollisionTexture.x = 1 - uvCollisionTexture.x;
    float2 uvParameter = float2(ParameterOffsetX, ParameterOffsetY) + uvLocal;
    
    //Read all the textures -°O°/
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvGlobal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvParameter, 0);
    float4 grassMapData = GrassMapTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);
    float4 simulationData0 = SimulationTexture.Load(uint3(id.xy, 0));
    float4 simulationData1 = SimulationTexture.Load(uint3(id.xy, 1));
    
    //Create and name all needed variables
	float width = parameters.x;
	float bendingFactor = parameters.y;
	float height = parameters.z * grassMapData.z;
	float invHeight = 1.0 / height;
	float dirAlpha = parameters.w;
	float3 localV0 = float3(uvLocal.x, normalHeight.w, uvLocal.y);
	float3 v0 = LocalToWorldPos(localV0).xyz;
	float3 bladeUp = normalize(normalHeight.xyz);
	float3 bladeDir;
	float3 bladeFront;
	CalculateBladeDirAndFront(bladeUp, dirAlpha, bladeDir, bladeFront);
	float mdt = DeltaTime;//min(DeltaTime, 1.0);
	float3 idleV2 = bladeUp * height;
	float3 v2 = simulationData1.xyz;
	float collisionForce = max(simulationData0.w - (1.0 - bendingFactor) * RecoveryFactor * mdt, 0.0);

	//Gravity
	float3 gravity = normalize(GravityVec.xyz) * GravityVec.w;
	float sign = step(-0.01, dot(normalize(gravity), bladeFront)) * 2.0 - 1.0;
	gravity += sign * bladeFront * height * GravityVec.w * 0.25;
	gravity = gravity * height * bendingFactor * mdt;

	//Wind
	float windageHeight = abs(dot(v2, bladeUp)) * invHeight;
	float windageDir = 1.0 - abs(dot(normalize(WindData.xyz), normalize(v2)));
	float windPos = 1.0f - max((cos((v0.x + v0.z) * 0.75f + WindData.w) + sin((v0.x + v0.y) * 0.5f + WindData.w) + sin((v0.y + v0.z) * 0.25f + WindData.w)) / 3.0f, 0.0f);
	float3 wind = WindData.xyz * windageDir * windageHeight * windPos * windPos * bendingFactor * mdt;
	
	//Stiffness 
	float3 stiffness = (idleV2 - v2) * (1.0 - bendingFactor * 0.5) * max(1.0 - collisionForce, 0.0) * mdt;

	//apply new forces
	v2 += gravity + wind + stiffness;

	//ValidateV2Tex(v2, v0);
	ValidateV2(v2, bladeUp);
    float3 v1 = GetV1(v2, bladeUp, height, invHeight);
    AdjustBezierArcLength(v1, v2, height);
    
    // Collisions
    bool dataDirty = false;
    //float3 cV0 = (GetCollisionVolumePos(v0).xyz);
    //cV0.xy = (cV0.xy + 1) / 2;
    
    //Test collision with v2
    /* 
     * Get v2 position in collider Volume
     * x,y are brought in range 0..1 so they can be used as texture coordinates 
     * z is depth, with 1 at near plane (ground level) and 0 at far plane
     */
    float3 cV2 = (GetCollisionVolumePos(v0 + v2).xyz);
    cV2.xy = (cV2.xy + 1) / 2;
    // Get collider data at v2
    float4 colliderDataAtV2 = CollisionDepthTexture.SampleLevel(samplerCollisionDepthTexture, cV2.xy, 0);
    // At first test if there is a collision
    float collisionDepthAtV2 = colliderDataAtV2.a - cV2.z;
    if (collisionDepthAtV2 > 0)
    {
        dataDirty = true;
        // Get ground depth at v2
        float groundDepthAtV2 = 1 - NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, cV2.xy, 0).w; 
        // Determine the applied pressure
        // First get the maximum possible collision depth
        float maxCollisionDepthAtV2 = groundDepthAtV2 - cV2.z;
        // TODO: test MIN_COLLISION_DEPTH
        // Determine the exact pressure the gets applied on v2 (the downward delta) in relative space
        float pressureAtV2 = min(collisionDepthAtV2, maxCollisionDepthAtV2);
        // and in worldSpace
        float worldSpacePressureAtV2 = pressureAtV2 * CollisionVolumeSize.y;
        
        float lengthV2 = length(v2);
        // Apply a collision to v2 control point
        // First apply colliders velocity to grass
        v2 += colliderDataAtV2.xyz * pressureAtV2;
        // Secondly apply a force along the gravity vector
        v2 += gravity * worldSpacePressureAtV2;
        
        lengthV2 = abs(lengthV2 - length(v2));
        
        // Determine the force of the collision. Depends on pressure and colliders velocity;
        collisionForce = max(collisionForce, lengthV2);
    }
    
    //Test collision with beziers midPoint
    /*float3 midPoint = 0.5f * v1 + 0.25f * v2;
    float3 cMidPoint = GetCollisionVolumePos(v0 + midPoint).xyz;
    cMidPoint.xy = (cMidPoint.xy + 1) / 2;
    float4 cDataAtMidPoint = CollisionDepthTexture.SampleLevel(samplerCollisionDepthTexture, cMidPoint.xy, 0);
    float cDepthAtMidPoint = cDataAtMidPoint.a;
    //float cPressureAtMidPoint = max(-cV0.z, cDepthAtMidPoint - cMidPoint.z);
    float cPressureAtMidPoint = min(0, cMidPoint.z - cDepthAtMidPoint);
    if (cPressureAtMidPoint < 0)
    {
        dataDirty = true;
        v2.xyz -= 4 * cDataAtMidPoint.xyz * cPressureAtMidPoint;
        v2.xyz -= 4 * gravity * (cPressureAtMidPoint * CollisionVolumeSize.y);
        collisionForce += max(length(cDataAtMidPoint.xyz), abs(cPressureAtMidPoint * CollisionVolumeSize.y));
    }
    */

    if (dataDirty)
    {
        //ValidateV2Tex(v2, v0);
        v2 = float3(0,0,0);
        ValidateV2(v2, bladeUp);
        v1 = GetV1(v2, bladeUp, height, invHeight);
        AdjustBezierArcLength(v1, v2, height);
    }
    
    float3 camDir = v0 - CamPos;
	float distance = length(camDir);

    SimulationTexture[uint3(id.xy, 0)] = float4(v1, collisionForce);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, distance);
}