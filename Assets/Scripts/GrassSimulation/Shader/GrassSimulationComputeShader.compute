//#pragma kernel CullingMain
#pragma kernel PhysicsMain
#pragma kernel SimulationSetup

#define physicsNumThreadsX 16
#define physicsNumThreadsY 16
#define physicsNumThreadsZ 1
#define physicsThreadCount physicsNumThreadsX * physicsNumThreadsY * physicsNumThreadsZ

#include "GrassSimulation.cginc"

//Once
Texture2D<float4> ParameterTexture; // width, bend, height, dirAlpha
SamplerState samplerParameterTexture;
float LodTessellationMin;
float LodTessellationMax;
float LodDistanceTessellationMin;
float LodDistanceTessellationMax;
            
//PerPatch
bool applyTransition;
float GrassDataResolution;
int startIndex;
float parameterOffsetX;
float parameterOffsetY;
float4x4 patchModelMatrix;

RWTexture2DArray<float4> SimulationTexture; //v1.xyz, tesslevel; v2.xyz, transition
Texture2D<float4> NormalHeightTexture; //up.xyz, pos.y
SamplerState samplerNormalHeightTexture;

//Per Frame
float deltaTime;
float4x4 viewProjMatrix;
float3 camPos;
float4 gravityVec;

//Per Patch

float4 LocalToWorldPos(float4 pos){
	return mul(patchModelMatrix, pos);
}

float4 LocalToWorldPos(float3 pos){
	return mul(patchModelMatrix, float4(pos, 1.0));
}

float4 WorldToClipPos(float4 pos){
	return mul(viewProjMatrix, pos);
}

float4 WorldToClipPos(float3 pos){
	return WorldToClipPos(float4(pos, 1.0));
}

/*
 * Kernels working on Textures below.
 */
 
float3 CalculateV1(float3 v2, float3 bladeUp, float height, float invHeight){
    float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0 - v2ratio, 0.05 * max(v2ratio, 1.0));
    return bladeUp * height * 0.5 * fac;
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void SimulationSetup(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //uint2 threadGroupCount = uint3(GrassDataResolution / physicsNumThreadsX, GrassDataResolution / physicsNumThreadsY);
    //uint i = (gid.z * threadGroupCount.y + gid.y) * threadGroupCount.x + gid.x * physicsThreadCount + gindex;
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    float2 uvGlobal = float2(parameterOffsetX, parameterOffsetY) + uvLocal;
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvLocal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);
    float3 bladeUp = normalize(normalHeight.xyz);
    float posY = normalHeight.w;
    float height = parameters.z;
    
    float3 v2 = bladeUp * height;
    float3 v1 = CalculateV1(v2, bladeUp, height, 1.0/height);
    
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);

    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
    
    float tessLevel = 12.0;
    float transition = 1.0;
    
    SimulationTexture[uint3(id.xy, 0)] = float4(v1, tessLevel);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, transition);
}

[numthreads(physicsNumThreadsX,physicsNumThreadsY,physicsNumThreadsZ)]
void PhysicsMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gindex : SV_GroupIndex)
{
    //uint2 threadGroupCount = uint3(GrassDataResolution / physicsNumThreadsX, GrassDataResolution / physicsNumThreadsY);
    //uint i = (gid.z * threadGroupCount.y + gid.y) * threadGroupCount.x + gid.x * physicsThreadCount + gindex;
    float2 uvLocal = float2(id.x/GrassDataResolution, id.y/GrassDataResolution);
    float2 uvGlobal = float2(parameterOffsetX, parameterOffsetY) + uvLocal;
    float4 normalHeight = NormalHeightTexture.SampleLevel(samplerNormalHeightTexture, uvLocal, 0);
    float4 parameters = ParameterTexture.SampleLevel(samplerParameterTexture, uvGlobal, 0);

    float4 simulationData0 = SimulationTexture.Load(uint3(id.xy, 0));
    float4 simulationData1 = SimulationTexture.Load(uint3(id.xy, 1));
    
	float width = parameters.x;
	float bendingFactor = parameters.y;
	float height = parameters.z;
	float invHeight = 1.0 / height;
	float dirAlpha = parameters.w;
	float3 localGroundPos = float3(uvLocal.x, normalHeight.w, uvLocal.y);
	float3 groundPos = LocalToWorldPos(localGroundPos).xyz;
	
	//direction of the blade
	float3 bladeUp = normalize(normalHeight.xyz);
	float sd = sin(dirAlpha);
	float cd = cos(dirAlpha);
	float3 tmp = normalize(float3(sd, sd + cd, cd)); //arbitrary vector for finding normal vector
	float3 bladeDir = normalize(cross(bladeUp, tmp));
	float3 bladeFront = normalize(cross(bladeUp, bladeDir));

	float mdt = min(deltaTime, 1.0);

	//float4 oldPressure = pressureDataBuffer[i];
	//float collisionForce = max(oldPressure.w - (1.0 - bendingFactor) * 0.5 * mdt, 0.0);
    
    //TODO
    
	float3 idleV2 = bladeUp * height;
	//apply old pressure
	//float3 v2 = idleV2 - oldPressure.xyz;
	float3 v2 = simulationData1.xyz;
	//float3 relativeV2 = v2 - groundPos;

	//gravity
	float3 gravity = normalize(gravityVec.xyz) * gravityVec.w;
	float sign = step(-0.01, dot(normalize(gravity), bladeFront)) * 2.0 - 1.0;
	gravity += sign * bladeFront * height * gravityVec.w * 0.25f;
	gravity = gravity * height * bendingFactor * mdt;

	//wind
	//TODO

	//stiffness //TODO: Rework temp max without collisionForce
	float3 stiffness = (idleV2 - v2) * (1.0 - bendingFactor * 0.25) * max(0.0, 0.1) * mdt;

	//apply new forces
	v2 += gravity + stiffness;
	//relativeV2 = v2 - groundPos;   
	
	//Ensure valid v2 position (not under ground plane)
	v2 += bladeUp * -min(dot(bladeUp, v2),0.0);

	//Calculate V1
	float3 g = v2 - dot(v2, bladeUp) * bladeUp;
    float v2ratio = abs(length(g) * invHeight);
    float fac = max(1.0 - v2ratio, 0.05 * max(v2ratio, 1.0));
    float3 v1 =  bladeUp * height * 0.5 * fac;

	//Make persistent length
	
    float3 v01 = v1;
    float3 v12 = v2 - v1;
    float lv01 = length(v1);
    float lv12 = length(v12);

    float L1 = lv01 + lv12;
    float L0 = length(v2);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 *= ldiff;
    v2 = v1 + v12;
	
	
	//float3 wV1 = LocalToWorldPos(localGroundPos + v1).xyz;
	//float3 wV2 = LocalToWorldPos(localGroundPos + v2).xyz;
	
	//float3 midPoint = 0.25 * groundPos + 0.5 * wV1 + 0.25 * wV2;

	//Visibility Check
	float3 camDir = groundPos - camPos;
	//Project camdir on the local plane defined by the up-vector
	float3 camDirProj = camDir - dot(camDir, bladeUp) * bladeUp;
	float distance = length(camDir);
	float projDistance = length(camDirProj);
	float3 camDirNorm = normalize(camDir);
    float tesslevel = SingleLerpMinMax(LodTessellationMin, LodTessellationMax, distance, LodDistanceTessellationMin, LodDistanceTessellationMax);

    /*if (distance > 400.0) //distance >= 200.0
	{
		tessDataBuffer[i].x = 0.0;
        return;
	}*/

	//Orientation Culling
    /*if(abs(dot(camDirNorm, bladeFront)) < 0.1)
    {
        tessDataBuffer[i].x = 0;
        return;
    }*/

    //Depth Culling
    /*float projDistance = length(camDirProj);
    uint value = ceil(max((1.0 - projDistance / 200.0),0.0) * 32.0);

    if(fmod(i,32) >= value)
    {
    	tessDataBuffer[i].x = 0;
        return;
    }*/
    
	//TODO: Collisions

    SimulationTexture[uint3(id.xy, 0)] = float4(v1, tesslevel);
    SimulationTexture[uint3(id.xy, 1)] = float4(v2, distance);
	//float3 pressure = v2 - idleV2;
	//grassDataBBuffer[i].xyz = v1;
	//grassDataCBuffer[i].xyz = v2;
	//pressureDataBuffer[i].xyz = pressure;
	//pressureDataBuffer[i].w = collisionForce;

}
